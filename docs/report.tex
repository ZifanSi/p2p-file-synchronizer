\documentclass[11pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  columns=fullflexible
}

\title{Assignment 2: Peer-to-Peer File Synchronizer\\Report (Test Cases \& Results)}
\author{Zifan Si \quad (Student \#400265867)}
\date{\today}

\begin{document}
\maketitle

\section{Overview}
This project implements a peer-to-peer (P2P) file synchronizer using a centralized tracker for peer discovery and directory aggregation. Each peer:
\begin{itemize}[noitemsep]
  \item establishes one persistent TCP connection to the tracker,
  \item advertises its working directory file metadata (name, integer mtime) on startup,
  \item sends periodic keepalive messages to maintain liveness (every 5 seconds),
  \item receives a directory response from the tracker after each Init/KeepAlive,
  \item downloads files that are missing locally or have older mtimes,
  \item serves file requests to other peers using a TCP protocol with a \texttt{Content-Length} header.
\end{itemize}

\section{Environment}
\begin{itemize}[noitemsep]
  \item OS: Windows (local testing)
  \item Python: 3.x
  \item Network: localhost (127.0.0.1)
\end{itemize}

\section{Project Layout Used for Testing}
Each peer is executed from its own working directory, and only files in that directory are advertised/served.
\begin{lstlisting}
Project/
  tracker.py
  fileSynchronizer.py
  run_all.bat
  Peer1/
    fileSynchronizer.py
    fileA.txt
  Peer2/
    fileSynchronizer.py
    fileB.txt
  Peer3/
    fileSynchronizer.py
    fileC.txt
\end{lstlisting}

\section{How to Run}
Tracker:
\begin{lstlisting}
python tracker.py 127.0.0.1 9000
\end{lstlisting}

Peers (each started from its own folder):
\begin{lstlisting}
cd Peer1 && python fileSynchronizer.py 127.0.0.1 9000
cd Peer2 && python fileSynchronizer.py 127.0.0.1 9000
cd Peer3 && python fileSynchronizer.py 127.0.0.1 9000
\end{lstlisting}

Optional batch script (starts tracker + 3 peers in separate Windows terminals):
\begin{lstlisting}
@echo off
set IP=127.0.0.1
set PORT=9000

start "TRACKER" cmd /k "python tracker.py %IP% %PORT%"

timeout /t 1 >nul

start "PEER1" cmd /k "cd /d %~dp0Peer1 && python fileSynchronizer.py %IP% %PORT%"
start "PEER2" cmd /k "cd /d %~dp0Peer2 && python fileSynchronizer.py %IP% %PORT%"
start "PEER3" cmd /k "cd /d %~dp0Peer3 && python fileSynchronizer.py %IP% %PORT%"
\end{lstlisting}

\section{Protocol Summary}
\subsection{Peer $\rightarrow$ Tracker}
Messages are newline-terminated UTF-8 JSON objects.
\begin{itemize}[noitemsep]
  \item Init (sent exactly once on startup):
  \begin{lstlisting}
{"port": <p>, "files": [{"name": "...", "mtime": <int>}, ...]}\n
  \end{lstlisting}
  \item KeepAlive (sent every 5 seconds):
  \begin{lstlisting}
{"port": <p>}\n
  \end{lstlisting}
\end{itemize}

\subsection{Tracker $\rightarrow$ Peer}
For every Init/KeepAlive received, the tracker returns one directory response (newline-terminated JSON):
\begin{lstlisting}
{"fileA.txt": {"ip":"...", "port":..., "mtime":...}, ...}\n
\end{lstlisting}

\subsection{Peer $\leftrightarrow$ Peer}
Requester sends:
\begin{lstlisting}
<filename>\n
\end{lstlisting}
Server responds:
\begin{lstlisting}
Content-Length: <size>\n
<raw file bytes>
\end{lstlisting}

\section{Selected Runtime Output Evidence}
The following excerpts are copied from an actual run on localhost with three peers.

\subsection*{Tracker (excerpt)}
\begin{lstlisting}
Waiting for connections on port 9000
Client connected with 127.0.0.1:60411
Client connected with 127.0.0.1:60412
Client connected with 127.0.0.1:60413
client server127.0.0.1:8000
client server127.0.0.1:8001
client server127.0.0.1:8002
\end{lstlisting}

\subsection*{Peer startup + directory responses (excerpt)}
\begin{lstlisting}
Peer2:
Waiting for connections on port 8000
('connect to:127.0.0.1', 9000)
received from tracker: {"fileB.txt": {"ip": "127.0.0.1", "port": 8000, "mtime": 1771289244}}

Peer1:
Waiting for connections on port 8001
('connect to:127.0.0.1', 9000)
received from tracker: {"fileB.txt": {"ip": "127.0.0.1", "port": 8000, "mtime": 1771289244},
"fileA.txt": {"ip": "127.0.0.1", "port": 8001, "mtime": 1771289241},
"fileC.txt": {"ip": "127.0.0.1", "port": 8002, "mtime": 1771289247}}

Peer3:
Waiting for connections on port 8002
('connect to:127.0.0.1', 9000)
received from tracker: {"fileB.txt": {"ip": "127.0.0.1", "port": 8000, "mtime": 1771289244},
"fileA.txt": {"ip": "127.0.0.1", "port": 8001, "mtime": 1771289241},
"fileC.txt": {"ip": "127.0.0.1", "port": 8002, "mtime": 1771289247}}
\end{lstlisting}

\section{Test Cases and Results}
This section documents test cases designed to validate all requirements in the protocol specification and grading rubric.

\subsection{TC0 (Rubric: get\_file\_info, 1pt): Working-directory file filtering}
\textbf{Goal:} Verify \texttt{get\_file\_info()} returns only valid files in the local working directory, ignores subdirectories and \texttt{.py/.dll/.so}, and reports integer mtimes.

\textbf{Setup:} In \texttt{Peer1/} create:
\begin{itemize}[noitemsep]
  \item \texttt{fileA.txt}
  \item \texttt{junk.dll}, \texttt{junk.so}, \texttt{temp.py}
  \item subfolder \texttt{sub/} containing \texttt{subfile.txt}
\end{itemize}

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Start Peer1 from \texttt{Peer1/}.
  \item Observe tracker directory response content received by peers.
\end{enumerate}

\textbf{Expected:}
\begin{itemize}[noitemsep]
  \item Only \texttt{fileA.txt} is advertised by Peer1 (no subfolder files, no \texttt{.py/.dll/.so}).
  \item Directory response contains integer \texttt{mtime} values.
\end{itemize}

\textbf{Observed:} Peer directory responses contained only \texttt{fileA.txt}, \texttt{fileB.txt}, \texttt{fileC.txt} (no filtered extensions or subfolder files). The returned \texttt{mtime} fields were integers, e.g.:
\begin{lstlisting}
"fileA.txt": {"ip":"127.0.0.1","port":8001,"mtime":1771289241}
\end{lstlisting}

\textbf{Result:} PASS.

\subsection{TC1 (Rubric: get\_next\_available\_port, 1pt): Port selection and bind success}
\textbf{Goal:} Verify each peer selects an available port and binds successfully (no collisions).

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Start tracker on \texttt{127.0.0.1:9000}.
  \item Start three peers.
\end{enumerate}

\textbf{Expected:} Each peer prints a distinct listening port and does not print a bind error.

\textbf{Observed:}
\begin{lstlisting}
Peer2: Waiting for connections on port 8000
Peer1: Waiting for connections on port 8001
Peer3: Waiting for connections on port 8002
\end{lstlisting}

\textbf{Result:} PASS.

\subsection{TC2 (Rubric: FileSynchronizer initializer, 1pt): Tracker connection and persistent communication}
\textbf{Goal:} Verify the initializer correctly sets up sockets, connects to tracker, advertises port/files (Init), and continues keepalive cycles.

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Start tracker.
  \item Start Peer1/Peer2/Peer3.
  \item Observe tracker accepts 3 client connections and prints peer addresses.
  \item Observe peers repeatedly print directory responses across time (keepalive cycles).
\end{enumerate}

\textbf{Expected:}
\begin{itemize}[noitemsep]
  \item Tracker logs 3 client connections.
  \item Tracker lists peer servers \texttt{127.0.0.1:8000/8001/8002}.
  \item Peers receive directory response after Init and subsequent keepalives.
\end{itemize}

\textbf{Observed:} Tracker output shows 3 connections and peer servers; peers repeatedly receive directory JSON:
\begin{lstlisting}
Client connected with 127.0.0.1:60411
Client connected with 127.0.0.1:60412
Client connected with 127.0.0.1:60413
client server127.0.0.1:8000
client server127.0.0.1:8001
client server127.0.0.1:8002
\end{lstlisting}

\textbf{Result:} PASS.

\subsection{TC3 (Rubric: sync discovery/retrieve, 1pt): Convergence (missing file download)}
\textbf{Goal:} Verify peers download missing files and converge so all peers have the same file set.

\textbf{Setup:} Initial state:
\begin{itemize}[noitemsep]
  \item Peer1 has only \texttt{fileA.txt}
  \item Peer2 has only \texttt{fileB.txt}
  \item Peer3 has only \texttt{fileC.txt}
\end{itemize}

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Start tracker and peers.
  \item Wait for 1--2 sync cycles (a few seconds).
  \item Check each peer folder contents.
\end{enumerate}

\textbf{Expected:} Each peer downloads the other missing files and ends with A/B/C.

\textbf{Observed:} After running, each peer folder contained:
\begin{lstlisting}
Peer1: fileA.txt fileB.txt fileC.txt
Peer2: fileA.txt fileB.txt fileC.txt
Peer3: fileA.txt fileB.txt fileC.txt
\end{lstlisting}
Directory responses remained stable across cycles, listing all three files with metadata.

\textbf{Result:} PASS.

\subsection{TC4 (Rubric: sync overwrite newer, 1pt): Newer mtime version propagates}
\textbf{Goal:} Verify a newer file version (larger mtime) overwrites older copies on other peers.

\textbf{Important assumption:} The specification states file contents do not change after a peer starts execution. Therefore, this test is executed by stopping peers, editing a file, then restarting.

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Stop all peers.
  \item Edit \texttt{Peer2/fileB.txt} (append a line) and save (mtime increases).
  \item Restart tracker (if needed) and restart peers.
  \item Wait 1--2 sync cycles.
  \item Compare \texttt{Peer1/fileB.txt} and \texttt{Peer3/fileB.txt} with Peer2.
\end{enumerate}

\textbf{Expected:} Peer1 and Peer3 download the newer \texttt{fileB.txt}. Their \texttt{mtime} is set to the advertised value via \texttt{os.utime()}.

\textbf{Observed:} Updated \texttt{fileB.txt} propagated to other peers; contents matched Peer2 after synchronization.

\textbf{Result:} PASS.

\subsection{TC5 (Rubric: process\_message, 2pt): Peer-to-peer file serving with Content-Length}
\textbf{Goal:} Verify the serving peer responds with the correct \texttt{Content-Length} header and sends exactly that many bytes.

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Ensure Peer3 has \texttt{fileC.txt}.
  \item Delete \texttt{Peer1/fileC.txt}.
  \item Wait for sync so Peer1 fetches \texttt{fileC.txt} from the peer listed in the directory response (Peer3).
  \item Verify downloaded file size and content matches the source file in Peer3.
\end{enumerate}

\textbf{Expected:}
\begin{itemize}[noitemsep]
  \item Peer1 receives a response starting with \texttt{Content-Length: <size>}.
  \item Peer1 reads exactly \texttt{<size>} bytes and writes the file in binary mode.
  \item Downloaded file matches source (size and content).
\end{itemize}

\textbf{Observed:} Peer1 successfully re-downloaded \texttt{fileC.txt}. The downloaded file matched the source content and size, consistent with correct \texttt{Content-Length} framing and exact byte transfer.

\textbf{Result:} PASS.

\subsection{TC6 (Rubric: failure handling, 1pt): Timeout/failure and discard partial files}
\textbf{Goal:} Verify failed transfers are handled gracefully (timeouts/failures do not leave partial files) and synchronization continues.

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Start tracker and all peers; confirm all peers have A/B/C.
  \item Stop Peer3 (simulate peer failure).
  \item Delete \texttt{Peer1/fileC.txt}.
  \item Wait 1--2 sync cycles.
  \item Check \texttt{Peer1/} for leftover partial file (e.g., \texttt{fileC.txt.part}).
  \item Restart Peer3 and wait for another sync cycle.
\end{enumerate}

\textbf{Expected:}
\begin{itemize}[noitemsep]
  \item When Peer3 is down, Peer1 cannot download \texttt{fileC.txt}.
  \item No partial file remains after a failed transfer.
  \item After Peer3 restarts, Peer1 downloads \texttt{fileC.txt} successfully.
\end{itemize}

\textbf{Observed:} With Peer3 stopped, \texttt{fileC.txt} was not retrieved and no \texttt{.part} file remained. After restarting Peer3, Peer1 downloaded \texttt{fileC.txt} successfully.

\textbf{Result:} PASS.

\section{Results Summary}
\begin{center}
\begin{tabular}{ll}
\toprule
Rubric Requirement / Test Case & Result \\
\midrule
TC0: \texttt{get\_file\_info()} filtering rules (1pt) & PASS \\
TC1: \texttt{get\_next\_available\_port()} (1pt) & PASS \\
TC2: FileSynchronizer initializer (1pt) & PASS \\
TC5: \texttt{process\_message()} + Content-Length (2pt) & PASS \\
TC3: \texttt{sync()} discovery + retrieve missing files (1pt) & PASS \\
TC4: \texttt{sync()} overwrite newer mtime (1pt) & PASS \\
TC6: Timeouts/failures + discard partial files (1pt) & PASS \\
\bottomrule
\end{tabular}
\end{center}

\section{Conclusion}
The implementation was validated against the protocol specification and grading rubric using custom test cases. The tests demonstrated correct working-directory file discovery and filtering, dynamic port selection, persistent tracker communication with periodic keepalives, peer-to-peer file serving using a \texttt{Content-Length} header, convergence to a consistent file set across peers, propagation of newer file versions via modification time, and correct handling of peer failures without leaving partial files.

\end{document}
