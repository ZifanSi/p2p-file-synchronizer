\documentclass[11pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  columns=fullflexible
}

\title{Assignment 2: Peer-to-Peer File Synchronizer\\Report (Test Cases \& Results)}
\author{Zifan Si \quad (Student \#400265867)}
\date{\today}

\begin{document}
\maketitle

The complete implementation, including source code, batch scripts, and test suites, is available at the following repository:

\vspace{0.5em}
\noindent GitHub: \url{https://github.com/ZifanSi/p2p-file-synchronizer}

\vspace{0.5em}
\noindent Codes in the \path{src/} directory, documentation in the \path{docs/} directory.


\section{Overview}
This project implements a peer-to-peer (P2P) file synchronizer using a centralized tracker for peer discovery and directory aggregation. Each peer:
\begin{itemize}[noitemsep]
  \item establishes one persistent TCP connection to the tracker,
  \item advertises working-directory file metadata (name, integer mtime) on startup (Init),
  \item sends periodic keepalive messages to maintain liveness (every 5 seconds),
  \item receives a directory response from the tracker after each Init/KeepAlive,
  \item downloads files that are missing locally or have older mtimes,
  \item serves file requests to other peers using a TCP protocol with a \texttt{Content-Length} header and raw bytes.
\end{itemize}

\section{Environment}
\begin{itemize}[noitemsep]
  \item OS: Windows 10/11 (local testing)
  \item Python: 3.12.10
  \item Network: localhost (127.0.0.1)
\end{itemize}

\section{Project Layout Used for Testing}
\begin{lstlisting}
src/
  bats/
    clean_peer.bat
    clean_port.bat
  Peer1/
    fileA.txt
  Peer2/
    fileB.txt
  Peer3/
    fileC.txt
    (generated in TC6) big.bin
  tests/
    compare_files.py
    tc_4.py
    tc_5.py
    tc_6.py
  fileSynchronizer.py
  run_all.bat
  tracker.py
\end{lstlisting}

\section{How to Run}

\subsection*{Option A: Run with the provided batch script (recommended)}
\begin{lstlisting}
cd src
(optional: reset peer folders to initial state with only fileA/B/C)
bats\clean_peer.bat
(optional: stop all peers and tracker; useful for clean restarts)
bats\clean_port.bat
run_all.bat
\end{lstlisting}

\subsection*{Option B: Run manually without \texttt{run\_all.bat}}
Open \textbf{4 terminals}.

\textbf{Terminal 1 (Tracker):}
\begin{lstlisting}
cd src
python tracker.py 127.0.0.1 9000
\end{lstlisting}

\textbf{Terminal 2 (Peer1):}
\begin{lstlisting}
cd src\Peer1
python ..\fileSynchronizer.py 127.0.0.1 9000
\end{lstlisting}

\textbf{Terminal 3 (Peer2):}
\begin{lstlisting}
cd src\Peer2
python ..\fileSynchronizer.py 127.0.0.1 9000
\end{lstlisting}

\textbf{Terminal 4 (Peer3):}
\begin{lstlisting}
cd src\Peer3
python ..\fileSynchronizer.py 127.0.0.1 9000
\end{lstlisting}


\section{Protocol Summary}
\subsection{Peer $\rightarrow$ Tracker}
Messages are newline-terminated UTF-8 JSON objects.
\begin{itemize}[noitemsep]
  \item Init (sent exactly once on startup):
\begin{lstlisting}
{"port": <p>, "files": [{"name": "...", "mtime": <int>}, ...]}\n
\end{lstlisting}
  \item KeepAlive (sent every 5 seconds):
\begin{lstlisting}
{"port": <p>}\n
\end{lstlisting}
\end{itemize}

\subsection{Tracker $\rightarrow$ Peer}
For every Init/KeepAlive received, the tracker returns one directory response (newline-terminated JSON):
\begin{lstlisting}
{"fileA.txt": {"ip":"...", "port":..., "mtime":...}, ...}\n
\end{lstlisting}

\subsection{Peer $\leftrightarrow$ Peer}
Requester sends:
\begin{lstlisting}
<filename>\n
\end{lstlisting}
Server responds:
\begin{lstlisting}
Content-Length: <size>\n
<raw file bytes>
\end{lstlisting}

\section{Rubric Coverage Map}
The following test cases are designed to cover every graded requirement:
\begin{itemize}[noitemsep]
  \item TC0: \texttt{get\_file\_info()} (1pt)
  \item TC1: \texttt{get\_next\_available\_port()} (1pt)
  \item TC2: \texttt{FileSynchronizer} initializer + tracker communication (1pt)
  \item TC3: \texttt{sync()} discovery + retrieve missing files (1pt)
  \item TC4: \texttt{sync()} overwrite newer mtime + \texttt{os.utime()} (1pt)
  \item TC5: \texttt{process\_message()} serves file with correct \texttt{Content-Length} framing (2pt)
  \item TC6: timeout/failure handling + discard partial file (1pt)
\end{itemize}

\section{Selected Runtime Output Evidence (localhost run)}
The following excerpts are copied from an actual run on localhost using:
\begin{itemize}[noitemsep]
  \item Tracker port: \textbf{9000}
  \item Peer1 port: \textbf{8000}
  \item Peer2 port: \textbf{8001}
  \item Peer3 port: \textbf{8002}
\end{itemize}

\subsection*{Tracker (excerpt)}
\begin{lstlisting}
Waiting for connections on port 9000
Client connected with 127.0.0.1:51543
Client connected with 127.0.0.1:51545
Client connected with 127.0.0.1:51546
client server127.0.0.1:8000
client server127.0.0.1:8001
client server127.0.0.1:8002
\end{lstlisting}

\subsection*{Peer directory responses (excerpt)}
\begin{lstlisting}
Peer1:
Waiting for connections on port 8000
('connect to:127.0.0.1', 9000)
received from tracker: {"fileA.txt": {"ip": "127.0.0.1", "port": 8000, "mtime": 1771289241}}
received from tracker: {"fileA.txt": {"ip": "127.0.0.1", "port": 8000, "mtime": 1771289241},
 "fileB.txt": {"ip": "127.0.0.1", "port": 8001, "mtime": 1771289244},
 "fileC.txt": {"ip": "127.0.0.1", "port": 8002, "mtime": 1771289247}}

Peer2:
Waiting for connections on port 8001
('connect to:127.0.0.1', 9000)
received from tracker: {"fileA.txt": {"ip": "127.0.0.1", "port": 8000, "mtime": 1771289241},
 "fileB.txt": {"ip": "127.0.0.1", "port": 8001, "mtime": 1771289244}}

Peer3:
Waiting for connections on port 8002
('connect to:127.0.0.1', 9000)
received from tracker: {"fileA.txt": {"ip": "127.0.0.1", "port": 8000, "mtime": 1771289241},
 "fileB.txt": {"ip": "127.0.0.1", "port": 8001, "mtime": 1771289244},
 "fileC.txt": {"ip": "127.0.0.1", "port": 8002, "mtime": 1771289247}}
\end{lstlisting}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{output.png}
    \caption{Output of the P2P File Synchronizer}
    \label{fig:output}
\end{figure}

\section{Test Cases and Results}

\subsection{TC0 (1pt): Working-directory file filtering via \texttt{get\_file\_info()}}
\textbf{Goal:} Verify only valid files in the working directory are advertised; ignore subdirectories and \texttt{.py/.dll/.so}; report integer mtimes.

\textbf{Setup:} In \texttt{src/Peer1/} create:
\begin{itemize}[noitemsep]
  \item \texttt{fileA.txt}
  \item \texttt{junk.dll}, \texttt{junk.so}, \texttt{temp.py}
  \item subfolder \texttt{sub/} containing \texttt{subfile.txt}
\end{itemize}

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Start tracker and peers.
  \item Observe directory response received by any peer.
\end{enumerate}

\textbf{Expected:}
\begin{itemize}[noitemsep]
  \item Only \texttt{fileA.txt} appears in the advertised directory from Peer1.
  \item \texttt{mtime} values are integers.
\end{itemize}

\textbf{Observed:} Only \texttt{fileA.txt} was listed (filtered files and subfolder were not). Example from directory response:
\begin{lstlisting}
"fileA.txt": {"ip": "127.0.0.1", "port": 8000, "mtime": 1771289241}
\end{lstlisting}

\textbf{Result:} PASS.

\subsection{TC1 (1pt): Next available port selection}
\textbf{Goal:} Verify each peer binds to an available port (no collisions).

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Start tracker (9000).
  \item Start three peers.
\end{enumerate}

\textbf{Expected:} Each peer prints a listening port and no bind errors occur.

\textbf{Observed (this run):}
\begin{lstlisting}
Peer1: Waiting for connections on port 8000
Peer2: Waiting for connections on port 8001
Peer3: Waiting for connections on port 8002
\end{lstlisting}

\textbf{Result:} PASS.

\subsection{TC2 (1pt): Initializer + tracker connection + keepalive cycles}
\textbf{Goal:} Verify sockets are initialized correctly, peers connect to tracker, send Init, and continue with KeepAlive (directory responses repeated over time).

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Start tracker and peers.
  \item Observe tracker accepts connections and peers receive directory responses.
  \item Wait $\ge$ 10 seconds and confirm additional directory responses occur (keepalive cycles).
\end{enumerate}

\textbf{Expected:} Tracker logs 3 connections; peers receive directory JSON repeatedly.

\textbf{Observed:} Tracker showed three connections (ports 51543, 51545, 51546) and peers repeatedly printed \texttt{received from tracker: \{...\}}.

\textbf{Result:} PASS.

\subsection{TC3 (1pt): Discovery and retrieve missing files (convergence)}
\textbf{Goal:} Verify peers download missing files and converge to the same directory.

\textbf{Setup (before run):}
\begin{itemize}[noitemsep]
  \item Peer1 has only \texttt{fileA.txt}
  \item Peer2 has only \texttt{fileB.txt}
  \item Peer3 has only \texttt{fileC.txt}
\end{itemize}

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Run \path{src\bats\clean_peer.bat}.
  \item Start tracker and peers.
  \item Wait 1--2 sync cycles.
  \item Check each peer folder contents.
\end{enumerate}

\textbf{Expected:} Each peer ends with A/B/C.

\textbf{Observed (after run):}
\begin{lstlisting}
Peer1: fileA.txt fileB.txt fileC.txt
Peer2: fileA.txt fileB.txt fileC.txt
Peer3: fileA.txt fileB.txt fileC.txt
\end{lstlisting}

\textbf{Result:} PASS.

\subsection{TC4 (1pt): Overwrite newer version + verify mtime set via \texttt{os.utime()}}
\textbf{Goal:} Verify a newer file version overwrites older copies and that the local mtime matches the advertised mtime.

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Stop all peers (or run \path{src\bats\clean_port.bat}).
  \item Append a line to \texttt{src/Peer2/fileB.txt} and save (mtime increases).
  \item Restart tracker and peers; wait 1--2 sync cycles.
  \item Record mtimes using the helper script:
\begin{lstlisting}
cd src
python tests\tc_4.py Peer2\fileB.txt
python tests\tc_4.py Peer1\fileB.txt
python tests\tc_4.py Peer3\fileB.txt
\end{lstlisting}
  \item Confirm content equality using:
\begin{lstlisting}
cd src
python tests\compare_files.py Peer2\fileB.txt Peer1\fileB.txt
python tests\compare_files.py Peer2\fileB.txt Peer3\fileB.txt
\end{lstlisting}
\end{enumerate}

\textbf{Expected:}
\begin{itemize}[noitemsep]
  \item Peer1/Peer3 overwrite their \texttt{fileB.txt} to match Peer2.
  \item Peer1/Peer3 integer mtimes equal Peer2's newer mtime (set by \texttt{os.utime()}).
\end{itemize}

\textbf{Observed:} After restart and synchronization, Peer1 and Peer3 matched Peer2's updated file (hash match via \texttt{compare\_files.py}) and mtimes (via \texttt{tc\_4.py}).

\textbf{Result:} PASS.

\subsection{TC5 (2pt): Peer serving protocol (\texttt{Content-Length} header + exact bytes)}
\textbf{Goal:} Verify server replies with correct header and sends exactly that many bytes.

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Ensure peers are running. In this run, Peer3 served files on port \textbf{8002}.
  \item Run:
\begin{lstlisting}
cd src
python tests\tc_5.py --port 8002 --file fileC.txt
\end{lstlisting}
\end{enumerate}

\textbf{Expected:}
\begin{itemize}[noitemsep]
  \item Prints \texttt{Content-Length: N}
  \item Prints \texttt{bytes=N expected=N}
\end{itemize}

\textbf{Observed:}
\begin{lstlisting}
Content-Length: 38
bytes=38 expected=38
\end{lstlisting}

\textbf{Result:} PASS.

\subsection{TC6 (1pt): Timeout/failure + discard partial file}
\textbf{Goal:} Verify failed transfers do not leave partial files and synchronization can recover after peer restart.

\textbf{Setup:} Create a larger file in Peer3 using the helper script:
\begin{lstlisting}
cd src\Peer3
python ..\tests\tc_6.py
\end{lstlisting}

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Start tracker and peers; confirm directory includes \texttt{big.bin}.
  \item Delete \texttt{src/Peer1/big.bin} if present.
  \item Wait for sync to begin, then force-stop Peer3 while transfer is in progress (close the Peer3 terminal).
  \item Verify Peer1 does not keep a partial file (no \texttt{big.bin.part} remains).
  \item Restart Peer3 and wait another sync cycle.
  \item Verify the final downloaded file matches Peer3 using:
\begin{lstlisting}
cd src
python tests\compare_files.py Peer3\big.bin Peer1\big.bin
\end{lstlisting}
\end{enumerate}

\textbf{Expected:}
\begin{itemize}[noitemsep]
  \item If the transfer is interrupted, Peer1 does not keep a partial file (no \texttt{.part} remains).
  \item After Peer3 restarts, Peer1 successfully downloads \texttt{big.bin} and it matches Peer3.
\end{itemize}

\textbf{Observed:} \texttt{tc\_6.py} generated \texttt{big.bin}. When Peer3 was force-stopped mid-transfer, \texttt{big.bin.part} was not left behind. After restarting Peer3, Peer1 retrieved \texttt{big.bin} and it matched Peer3 (verified by \texttt{compare\_files.py}).

\textbf{Result:} PASS.

\section{Results Summary}
\begin{center}
\begin{tabular}{ll}
\toprule
Rubric Requirement / Test Case & Result \\
\midrule
TC0: \texttt{get\_file\_info()} filtering rules (1pt) & PASS \\
TC1: \texttt{get\_next\_available\_port()} (1pt) & PASS \\
TC2: Initializer + tracker comms + keepalive (1pt) & PASS \\
TC3: \texttt{sync()} discovery + retrieve missing (1pt) & PASS \\
TC4: \texttt{sync()} overwrite newer + set mtime (1pt) & PASS \\
TC5: \texttt{process\_message()} Content-Length + exact bytes (2pt) & PASS \\
TC6: Failure handling + discard partial file (1pt) & PASS \\
\bottomrule
\end{tabular}
\end{center}

\section{Conclusion}
Custom test cases were designed to validate all protocol requirements and grading rubric items. The results demonstrate correct working-directory discovery and filtering, available-port binding, persistent tracker communication and keepalives, peer serving with \texttt{Content-Length} framing and exact byte transfer, convergence across peers, propagation of newer file versions with mtime preservation via \texttt{os.utime()}, and robust handling of failures without leaving partial files.

\end{document}