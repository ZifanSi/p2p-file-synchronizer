\documentclass[11pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  columns=fullflexible
}

\title{P2P File Synchronizer --- Report (Test Cases \& Results)}
\author{Zifan Si \quad (Student \#400265867)}
\date{\today}

\begin{document}
\maketitle

\section{Overview}
This assignment implements a peer-to-peer file synchronizer using a centralized tracker. Each peer:
\begin{itemize}[noitemsep]
  \item discovers peers and file metadata from the tracker,
  \item downloads missing or newer files from other peers (by mtime),
  \item serves file requests from peers using a simple TCP protocol with a \texttt{Content-Length} header.
\end{itemize}

\section{Environment}
\begin{itemize}[noitemsep]
  \item OS: Windows (local testing)
  \item Python: 3.x
  \item Network: localhost (127.0.0.1)
\end{itemize}

\section{Project Layout Used for Testing}
\begin{lstlisting}
Project/
  tracker.py
  run_all.bat
  fileSynchronizer.py
  Peer1/
    fileSynchronizer.py
    fileA.txt
  Peer2/
    fileSynchronizer.py
    fileB.txt
  Peer3/
    fileSynchronizer.py
    fileC.txt
\end{lstlisting}

\section{How to Run}
Tracker:
\begin{lstlisting}
python tracker.py 127.0.0.1 9000
\end{lstlisting}

Peers (each started from its own folder):
\begin{lstlisting}
cd Peer1 && python fileSynchronizer.py 127.0.0.1 9000
cd Peer2 && python fileSynchronizer.py 127.0.0.1 9000
cd Peer3 && python fileSynchronizer.py 127.0.0.1 9000
\end{lstlisting}

(Optional) Batch script:
\begin{lstlisting}
run_all.bat
\end{lstlisting}

\section{Protocol Summary}
\subsection{Peer $\rightarrow$ Tracker}
Messages are newline-terminated JSON.
\begin{itemize}[noitemsep]
  \item Init (once): \texttt{\{"port": <p>, "files": [\{"name":..., "mtime":...\}, ...]\}}
  \item KeepAlive (periodic): \texttt{\{"port": <p>\}}
\end{itemize}

\subsection{Peer $\leftrightarrow$ Peer}
Requester sends:
\begin{lstlisting}
<filename>\n
\end{lstlisting}
Server responds:
\begin{lstlisting}
Content-Length: <size>\n
<raw file bytes>
\end{lstlisting}

\section{Selected Runtime Output Evidence}
The following excerpts are copied from an actual run on localhost with three peers, and are referenced in the test cases below.

\subsection*{Tracker (excerpt)}
\begin{lstlisting}
Waiting for connections on port 9000
Client connected with 127.0.0.1:60411
Client connected with 127.0.0.1:60412
Client connected with 127.0.0.1:60413
client server127.0.0.1:8000
client server127.0.0.1:8001
client server127.0.0.1:8002
\end{lstlisting}

\subsection*{Peer startup + directory responses (excerpt)}
\begin{lstlisting}
Peer2:
Waiting for connections on port 8000
('connect to:127.0.0.1', 9000)
received from tracker: {"fileB.txt": {"ip": "127.0.0.1", "port": 8000, "mtime": 1771289244}}

Peer1:
Waiting for connections on port 8001
('connect to:127.0.0.1', 9000)
received from tracker: {"fileB.txt": {"ip": "127.0.0.1", "port": 8000, "mtime": 1771289244},
"fileA.txt": {"ip": "127.0.0.1", "port": 8001, "mtime": 1771289241},
"fileC.txt": {"ip": "127.0.0.1", "port": 8002, "mtime": 1771289247}}

Peer3:
Waiting for connections on port 8002
('connect to:127.0.0.1', 9000)
received from tracker: {"fileB.txt": {"ip": "127.0.0.1", "port": 8000, "mtime": 1771289244},
"fileA.txt": {"ip": "127.0.0.1", "port": 8001, "mtime": 1771289241},
"fileC.txt": {"ip": "127.0.0.1", "port": 8002, "mtime": 1771289247}}
\end{lstlisting}

\section{Test Cases and Results}
\subsection{TC0: get\_file\_info() Filtering Rules}
\textbf{Goal:} Verify only valid files in the local directory are included, and filtering matches the rules.

\textbf{Setup:} In \texttt{Peer1/} create:
\begin{itemize}[noitemsep]
  \item \texttt{fileA.txt}
  \item \texttt{junk.dll}, \texttt{junk.so}, \texttt{temp.py}
  \item subfolder \texttt{sub/} containing \texttt{subfile.txt}
\end{itemize}

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Start Peer1 and observe what it advertises (via tracker directory response content).
\end{enumerate}

\textbf{Expected:}
\begin{itemize}[noitemsep]
  \item Only \texttt{fileA.txt} is included.
  \item No subfolder files appear.
  \item \texttt{mtime} values are integers.
\end{itemize}

\textbf{Observed:} Only \texttt{fileA.txt} appeared in the directory listing; ignored \texttt{.py/.dll/.so} and subfolder.

\textbf{Result:} PASS.

\subsection{TC1: get\_next\_available\_port() / Bind Success}
\textbf{Goal:} Verify each peer binds to an available port (no collisions).

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Start tracker on \texttt{127.0.0.1:9000}.
  \item Start Peer1, Peer2, Peer3.
\end{enumerate}

\textbf{Expected:} Each peer prints \texttt{Waiting for connections on port <p>} with distinct ports.

\textbf{Observed:} From runtime output:
\begin{lstlisting}
Peer2: Waiting for connections on port 8000
Peer1: Waiting for connections on port 8001
Peer3: Waiting for connections on port 8002
\end{lstlisting}

\textbf{Result:} PASS.

\subsection{TC2: Tracker Registration \& Directory Aggregation}
\textbf{Goal:} Verify peers register to the tracker and the tracker directory contains all files.

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Initial state: Peer1 has \texttt{fileA.txt}, Peer2 has \texttt{fileB.txt}, Peer3 has \texttt{fileC.txt}.
  \item Start tracker and peers.
\end{enumerate}

\textbf{Expected:} Tracker accepts connections and peers receive a directory JSON containing A/B/C with (ip, port, mtime).

\textbf{Observed:} From tracker output:
\begin{lstlisting}
Client connected with 127.0.0.1:60411
Client connected with 127.0.0.1:60412
Client connected with 127.0.0.1:60413
\end{lstlisting}
And from peer output (directory contains all three files with metadata):
\begin{lstlisting}
received from tracker: {"fileB.txt": {"ip": "127.0.0.1", "port": 8000, "mtime": 1771289244},
"fileA.txt": {"ip": "127.0.0.1", "port": 8001, "mtime": 1771289241},
"fileC.txt": {"ip": "127.0.0.1", "port": 8002, "mtime": 1771289247}}
\end{lstlisting}

\textbf{Result:} PASS.

\subsection{TC3: Missing File Download (Convergence)}
\textbf{Goal:} Verify peers download missing files and all peers converge to the same set.

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Ensure Peer1 has only \texttt{fileA.txt}, Peer2 only \texttt{fileB.txt}, Peer3 only \texttt{fileC.txt}.
  \item Start tracker and peers; wait for 1--2 sync cycles.
\end{enumerate}

\textbf{Expected:} Each peer downloads the missing files and ends with A/B/C.

\textbf{Observed:} After running, directory listings showed each peer folder contained:
\begin{lstlisting}
Peer1: fileA.txt fileB.txt fileC.txt
Peer2: fileA.txt fileB.txt fileC.txt
Peer3: fileA.txt fileB.txt fileC.txt
\end{lstlisting}
Also, the repeated directory responses showing all three files remained stable across sync cycles.

\textbf{Result:} PASS.

\subsection{TC4: Newer Version Wins (mtime Update)}
\textbf{Goal:} Verify a newer file version propagates based on modification time.

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Edit \texttt{Peer2/fileB.txt} (append a line) and save.
  \item Wait 1--2 sync cycles.
  \item Compare \texttt{Peer1/fileB.txt} and \texttt{Peer3/fileB.txt} content to Peer2.
\end{enumerate}

\textbf{Expected:} Peer1 and Peer3 fetch the updated \texttt{fileB.txt} and match Peer2. File \texttt{mtime} becomes the newer value.

\textbf{Observed:} Updated \texttt{fileB.txt} propagated to other peers; contents matched Peer2 after synchronization.

\textbf{Result:} PASS.

\subsection{TC5: Peer Serving Protocol (Content-Length Correctness)}
\textbf{Goal:} Verify file transfers use the correct \texttt{Content-Length} and exact bytes.

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Delete \texttt{Peer1/fileC.txt}.
  \item Wait for sync so Peer1 fetches \texttt{fileC.txt} from Peer3.
  \item Verify the downloaded file size matches the source and the content is identical.
\end{enumerate}

\textbf{Expected:} Peer1 receives \texttt{Content-Length: <size>} and writes exactly that many bytes.

\textbf{Observed:} Downloaded \texttt{fileC.txt} matched the source content and size.

\textbf{Result:} PASS.

\subsection{TC6: Failure Handling (Peer Down / Discard Partial)}
\textbf{Goal:} Verify that failed downloads do not leave partial files and synchronization continues.

\textbf{Steps:}
\begin{enumerate}[noitemsep]
  \item Start tracker and all peers; confirm all have A/B/C.
  \item Stop Peer3 process (simulate a peer crash).
  \item Delete \texttt{Peer1/fileC.txt}.
  \item Wait 1--2 sync cycles.
  \item Check Peer1 directory for any leftover \texttt{fileC.txt.part}.
  \item Restart Peer3 and wait for sync again.
\end{enumerate}

\textbf{Expected:}
\begin{itemize}[noitemsep]
  \item When Peer3 is down, Peer1 cannot download \texttt{fileC.txt}.
  \item No partial file (\texttt{.part}) remains after a failed transfer.
  \item After Peer3 restarts, Peer1 successfully downloads \texttt{fileC.txt}.
\end{itemize}

\textbf{Observed:} With Peer3 stopped, \texttt{fileC.txt} was not retrieved and no \texttt{.part} file remained. After restarting Peer3, Peer1 downloaded \texttt{fileC.txt} successfully.

\textbf{Result:} PASS.

\section{Results Summary}
\begin{center}
\begin{tabular}{ll}
\toprule
Test Case & Result \\
\midrule
TC0: get\_file\_info() filtering & PASS \\
TC1: port selection / bind & PASS \\
TC2: tracker registration + directory & PASS \\
TC3: missing file download & PASS \\
TC4: mtime update propagation & PASS \\
TC5: Content-Length correctness & PASS \\
TC6: failure handling / discard partial & PASS \\
\bottomrule
\end{tabular}
\end{center}

\section{Conclusion}
The implementation was validated with tests covering file filtering, port selection, tracker interaction, peer file serving, synchronization convergence, update propagation by mtime, and basic failure handling.

\end{document}
